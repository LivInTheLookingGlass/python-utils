1.  **Routing and Packet Structure**

 There are two layers to be concerned about in this network structure. The first is a pathfinding layer. This is the capsule in which all messages will be wrapped.

 The second is a messaging layer. This deals with how nodes are supposed to respond to various signals, whether the message is for mass broadcast, etc.
        
 Packets are arranged like so, separated by a pre-defined flag:

        Pathfinding header      -       [broadcast, waterfall, whisper, peer, peer-waterfall, TBD]
        Sender ID               -       A base58 SHA384-based unique ID for the sender. Construction defined later.
        Message ID              -       A base58 SHA384 hash of the message packet
        Timestamp               -       An integer unix timestamp of initial broadcast
        Message packet
            Message header      -       [message, reply, whisper, handshake, TBD]
            Message contents
        End of transaction flag


2.  **Node Construction**

 A node consists of two threads. The first is strictly for broadcasting and user interaction. The second is for receiving and automated responses.

 A node also consists of several distinct parts.

 1. A routing table of peers with the IDs and corresponding addresses
 2. A "waterfall queue" of recently received message IDs and timestamps
 3. A user-interactable queue of recently received messages
 4. An incoming socket object, to deal with new peers and message receiving
 5. A quantity-limited list of outgoing connections
 6. A "protocol", which contains:
     1. An end-of-packet string
     2. A separator string
     3. A sub-net flag
     4. A way to obtain a SHA256-based ID of this (defined later)


3.  **Message Propagation**

 A message is initially broadcast with the "broadcast" (or if it's a new-peer broadcast, "peer") flag. The broadcasting node, as well as all receivers, store this message's hash and timestamp in their waterfall queue. The reciving nodes then re-broadcast this message to each of their peers, but changing the flag to "waterfall" (or if it's a new-peer broadcast, "peer-waterfall").

 A node which receives these waterfall packets goes through the following checks:

 1. If the message hash is not in the node's waterfall queue, continue and add it to the waterfall queue
 2. Perform cleanup on the waterfall queue
     1. Remove all IDs with a timestamp more than 1 minute ago
     2. Reduce the queue size to 256
 3. Re-broadcast this message to all peers


4.  **ID Constructions**

 1. Defining base_58
 
     The following python code defin's base\_58 for the purposes of this program. This is derived from Bitcoin's base_58.
    
        ```python
        def to_base_58(i):
            string = ""
            while i:
                string = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'[i % 58] + string
                i = i // 58
            return string

        def from_base_58(string):
            decimal = 0
            for char in string:
                decimal = decimal * 58 + '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.index(char)
            return decimal
        ```

 2. Protocol IDs
 
     A protocol ID is generated by the following python pseudo-code, where this is called on the protocol object, which is based on a namedtuple.
     
     The version is defined in the code itself. As of this documents last update the version is "0.0.F"
        
        ```python
        def id(self):
            h = hashlib.sha256(''.join([str(x) for x in self] + [version]).encode())
            return to_base_58(int(h.hexdigest(), 16))
        ```

 3. Node IDs
           
     A node generates it's ID by the following python pseudo-code, where this is called on the incoming connection, and the user_salt is a uuid4:

        ```python
        def get_id(self):
            info = [str(self.addr), self.protocol.id(), user_salt]
            h = hashlib.sha384(''.join(info).encode())
            return to_base_58(int(h.hexdigest(), 16))
        ```


5.  **Handshake Exchanges**

 To connect to the messaging layer (and thus get announced to the rest of the network) you must make a handshake exchange with at least one connection to the network.
 
 In order to do so, you first make a connection to the receiving node. You and the recieving node then immediately broadcast two transactions to each other.

        1.  whisper
            [your id]
            [timestamp]
            handshake
            [your id]
            [your outward-facing address]
            [json-ized list of your supported compression methods, in order of preference]
            End of tx

        2.  whisper
            [your id]
            [timestamp]
            peers
            [json-ized copy of your routing table]
            End of tx


6.  **Methods of Encryption**

 The network will support any communications object which extends a standard socket object. This ensures that it does not care whether it is stacked on top of TCP, TLS, or RSA-encrypted TCP. The reference implementation will use TCP or RSA-encrypted TCP. TLS will be included if I can figure out how to generate self-signed certificates in native python.


7.	Potential flaws

 The network has a few immediately obvious shortcomings.

 First, in a worst case scenario, every node will receive a given message n-1 times, where n is the number of connected nodes. In most larger cases this will not happen, as a given node will not be connected to everyone else. But in smaller networks this will be common, and in well-connected networks this could slow things down. This calls for optimization, and will need to be explored.

 Second, there is quite a lot of extra data being sent. Using the default parameters, if you want to send a 4 character message it will be expanded to 162 characters. That's ~40x larger. If you want these differences to be negligble, you need to send messages on the order of 1024 characters. Then there is only an increase of ~15%. This can be improved by reducing the size of the various IDs being sent, making the packet separators shorter, or allowing opportunistic compression. All of these have disadvantages, however. (If you're using my RSA implementation, this increase gets ~10% larger depending on keysize. Opportunistic compression would counteract the vast majority of this, as cursory testing with gzip shows that even a 0 character message has ~15% size reduction.)
