# TODO:	Rewrite secure_socket to properly implement recv
#		Allow p2p_connection to default to RSA_encrypted TCP

1. 	Routing and Packet Structure
		There are two layers to be concerned about in this network structure. The first is a pathfinding layer. This is the capsule in which all messages will be wrapped.
		The second is a messaging layer. This deals with how nodes are supposed to respond to various signals, whether the message is for mass broadcast, etc.
		Packets are arranged like so, separated by a pre-defined flag:

		Pathfinding header		-		[broadcast, waterfall, whisper, peer, peer-waterfall, TBD]
		Sender ID				-		A base58 SHA384-based unique ID for the sender. Construction defined later.
		Message ID				-		A base58 SHA384 hash of the message packet
		Timestamp				-		An integer unix timestamp of initial broadcast
		Message packet
			Message header		-		[message, reply, whisper, handshake, TBD]
			Message contents
		End of transaction flag


2.	Node Construction
		A node consists of two threads. The first is strictly for broadcasting and user interaction. The second is for receiving and automated responses.
		A node also consists of several distinct parts.

		1. A routing table of peers with the IDs and corresponding addresses
		2. A "waterfall queue" of recently received message IDs and timestamps
		3. A user-interactable queue of recently received messages
		4. An incoming socket object, to deal with new peers and message receiving
		5. A quantity-limited list of outgoing connections
		6. A "protocol", which contains:
			1. An end-of-packet string
			2. A separator string
			3. A sub-net flag
			4. A way to obtain a SHA256-based ID of this (defined later)


3.	Message Propagation
		A message is initially broadcast with the "broadcast" (or if it's a new-peer broadcast, "peer") flag. The broadcasting node, as well as all receivers, store
		this message's hash and timestamp in their waterfall queue. The reciving nodes then re-broadcast this message to each of their peers, but changing the flag to
		"waterfall" (or if it's a new-peer broadcast, "peer-waterfall").

		A node which receives these waterfall packets goes through the following checks:

		1. If the message hash is not in the node's waterfall queue, continue and add it to the waterfall queue
		2. Perform cleanup on the waterfall queue
			1. Remove all IDs with a timestamp more than 1 minute ago
			2. Reduce the queue size to 100
		3. Re-broadcast this message to all peers


4.	ID Constructions
	4a.	Defining base_58
			The following python code define's base_58 for the purposes of this program. This is derived from Bitcoin's base_58.

			def to_base_58(i):
				string = ""
				while i:
					string = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'[i % 58] + string
					i = i / 58
				return string

			def from_base_58(string):
				decimal = 0
				for char in string:
					decimal = decimal * 58 + '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'.index(char)
				return decimal

	4b.	Protocol IDs
			A protocol ID is generated by the following python pseudo-code, where this is called on the protocol object, which is based on a namedtuple.
			The version is defined in the code itself. As of this documents last update the version is "0.0.F"

			def id(self):
		        h = hashlib.sha256(''.join([str(x) for x in self] + [version]).encode())
		        return to_base_58(int(h.hexdigest(), 16))

	4c.	Node IDs
			A node generates it's ID by the following python pseudo-code, where this is called on the incoming connection, and the user_salt is a uuid4:

			def get_id(self):
				info = [str(self.addr), self.protocol.id(), user_salt]
		        h = hashlib.sha384(''.join(info).encode())
		        return to_base_58(int(h.hexdigest(), 16))


5.	Handshake Exchanges
		To connect to the messaging layer (and thus get announced to the rest of the network) you must make a handshake exchange with at least one connection to the network.
		In order to do so, you first make a connection to the receiving node. You and the recieving node then immediately broadcast two transactions to each other.

		1. 	whisper
			[your id]
			[timestamp]
			handshake
			[your id]
			[your outward-facing address]
			End of tx

		2.	whisper
			[your id]
			[timestamp]
			peers
			json-ized copy of your routing table
			End of tx


6.	Methods of Encryption
		The network will support any communications object which extends a standard socket object. This ensures that it does not care whether it is stacked on top of TCP, TLS, or RSA-encrypted TCP. The reference implementation will use TCP or RSA-encrypted TCP. TLS will be included if I can figure out how to generate self-signed certificates in native python.
